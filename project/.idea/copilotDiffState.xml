<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TODO_DATABASE_FUNCTIONS.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TODO_DATABASE_FUNCTIONS.kt" />
              <option name="updatedContent" value="// DatabaseHelper.kt - FUNZIONI DA IMPLEMENTARE PER IL SISTEMA ORDINI&#10;// Aggiungi queste funzioni alla classe DatabaseHelper&#10;&#10;package com.test.project.database&#10;&#10;// ============================================&#10;// FUNZIONI PER GLI ORDINI - DA IMPLEMENTARE&#10;// ============================================&#10;&#10;/*&#10; * 1. Ottieni tutti gli ordini di un utente&#10; * Ritorna una lista di ordini (Order) per l'utente specificato&#10; */&#10;fun getAllOrdersForUser(userId: Int): List&lt;Order&gt; {&#10;    val orders = mutableListOf&lt;Order&gt;()&#10;    val db = readableDatabase&#10;    val cursor = db.rawQuery(&quot;SELECT * FROM orders WHERE userId = ?&quot;, arrayOf(userId.toString()))&#10;    &#10;    while (cursor.moveToNext()) {&#10;        val order = Order.getFromCursor(cursor)&#10;        orders.add(order)&#10;    }&#10;    cursor.close()&#10;    return orders&#10;}&#10;&#10;/*&#10; * 2. Ottieni tutti i piatti di un ordine&#10; * Ritorna una lista di Dish per l'ordine specificato&#10; * Nota: Devi fare JOIN tra order_elements e dishes&#10; */&#10;fun getOrderItems(orderId: Int): List&lt;Dish&gt; {&#10;    val dishes = mutableListOf&lt;Dish&gt;()&#10;    val db = readableDatabase&#10;    val query = &quot;&quot;&quot;&#10;        SELECT d.* FROM dishes d&#10;        JOIN order_elements oe ON d.id = oe.dishId&#10;        WHERE oe.orderId = ?&#10;    &quot;&quot;&quot;&#10;    val cursor = db.rawQuery(query, arrayOf(orderId.toString()))&#10;    &#10;    while (cursor.moveToNext()) {&#10;        val dish = Dish.getFromCursor(cursor)&#10;        dishes.add(dish)&#10;    }&#10;    cursor.close()&#10;    return dishes&#10;}&#10;&#10;/*&#10; * 3. Elimina un elemento da un ordine&#10; * Rimuove la relazione tra orderId e dishId dalla tabella order_elements&#10; */&#10;fun deleteOrderElement(orderId: Int, dishId: Int): Boolean {&#10;    val db = writableDatabase&#10;    val result = db.delete(&#10;        &quot;order_elements&quot;,&#10;        &quot;orderId = ? AND dishId = ?&quot;,&#10;        arrayOf(orderId.toString(), dishId.toString())&#10;    )&#10;    return result &gt; 0&#10;}&#10;&#10;/*&#10; * 4. Conta quanti elementi ha un ordine&#10; * Utile per mostrare &quot;X items&quot; nella lista ordini&#10; */&#10;fun getOrderItemsCount(orderId: Int): Int {&#10;    val db = readableDatabase&#10;    val cursor = db.rawQuery(&#10;        &quot;SELECT COUNT(*) FROM order_elements WHERE orderId = ?&quot;,&#10;        arrayOf(orderId.toString())&#10;    )&#10;    var count = 0&#10;    if (cursor.moveToFirst()) {&#10;        count = cursor.getInt(0)&#10;    }&#10;    cursor.close()&#10;    return count&#10;}&#10;&#10;/*&#10; * 5. Calcola il totale di un ordine&#10; * Somma i prezzi di tutti i piatti nell'ordine&#10; */&#10;fun getOrderTotal(orderId: Int): Double {&#10;    val db = readableDatabase&#10;    val query = &quot;&quot;&quot;&#10;        SELECT SUM(d.price) as total FROM dishes d&#10;        JOIN order_elements oe ON d.id = oe.dishId&#10;        WHERE oe.orderId = ?&#10;    &quot;&quot;&quot;&#10;    val cursor = db.rawQuery(query, arrayOf(orderId.toString()))&#10;    var total = 0.0&#10;    if (cursor.moveToFirst()) {&#10;        total = cursor.getDouble(cursor.getColumnIndexOrThrow(&quot;total&quot;))&#10;    }&#10;    cursor.close()&#10;    return total&#10;}&#10;&#10;/*&#10; * 6. Ottieni il ristorante di un ordine (già esiste getRestaurantById?)&#10; * Se non esiste, creala così:&#10; */&#10;fun getRestaurantById(restaurantId: Int): Restaurant? {&#10;    val db = readableDatabase&#10;    val cursor = db.rawQuery(&quot;SELECT * FROM restaurants WHERE id = ?&quot;, arrayOf(restaurantId.toString()))&#10;    var restaurant: Restaurant? = null&#10;    if (cursor.moveToFirst()) {&#10;        restaurant = Restaurant.getFromCursor(cursor)&#10;    }&#10;    cursor.close()&#10;    return restaurant&#10;}&#10;&#10;/*&#10; * BONUS: Aggiungi un ordine (se vuoi implementare anche la creazione)&#10; */&#10;fun addOrder(userId: Int, restaurantId: Int): Long {&#10;    val db = writableDatabase&#10;    val order = Order(userId = userId, restaurantId = restaurantId)&#10;    return db.insert(&quot;orders&quot;, null, order.toContentValues())&#10;}&#10;&#10;/*&#10; * BONUS: Aggiungi un elemento a un ordine&#10; */&#10;fun addOrderElement(orderId: Int, dishId: Int): Boolean {&#10;    val db = writableDatabase&#10;    val orderElement = OrderElement(orderId = orderId, dishId = dishId)&#10;    val result = db.insert(&quot;order_elements&quot;, null, orderElement.toContentValues())&#10;    return result != -1L&#10;}&#10;&#10;// ============================================&#10;// COME USARE QUESTE FUNZIONI NELLE PAGINE&#10;// ============================================&#10;&#10;/*&#10; * OrdersViewActivity.kt - nella funzione loadOrders():&#10; * &#10; * val orders = databaseHelper.getAllOrdersForUser(userId)&#10; * &#10; * Poi per ogni ordine puoi ottenere:&#10; * - Nome ristorante: databaseHelper.getRestaurantById(order.restaurantId)?.name&#10; * - Numero items: databaseHelper.getOrderItemsCount(order.orderId!!)&#10; * - Totale: databaseHelper.getOrderTotal(order.orderId!!)&#10; */&#10;&#10;/*&#10; * OrderDetailActivity.kt - nella funzione loadOrderItems():&#10; * &#10; * val dishes = databaseHelper.getOrderItems(orderIdValue)&#10; * &#10; * E per eliminare un elemento:&#10; * val success = databaseHelper.deleteOrderElement(orderIdValue, dishId)&#10; */&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/test/project/Dish.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/test/project/Dish.kt" />
              <option name="updatedContent" value="package com.test.project&#10;&#10;data class Dish(&#10;    val id: Int,&#10;    val name: String,&#10;    val description: String,&#10;    val price: Double,&#10;    val imageUrl: String? = null&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/test/project/LoginPageActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/test/project/LoginPageActivity.kt" />
              <option name="originalContent" value="package com.test.project&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.test.project.database.DatabaseHelper&#10;import org.mindrot.jbcrypt.BCrypt&#10;import androidx.core.content.edit&#10;&#10;class LoginPageActivity : AppCompatActivity()&#10;{&#10;    lateinit var usernameInput : EditText&#10;    lateinit var passwordInput : EditText&#10;    lateinit var loginBtn : Button&#10;&#10;    lateinit var databaseHelper: DatabaseHelper&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?)&#10;    {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Check if user is already logged in&#10;        if (isUserLoggedIn()) {&#10;            val intent = Intent(this, RestaurantViewActivity::class.java)&#10;            startActivity(intent)&#10;            finish()&#10;            return&#10;        }&#10;&#10;        setContentView(R.layout.activity_login_page)&#10;&#10;        databaseHelper = DatabaseHelper(this)&#10;&#10;        usernameInput = findViewById(R.id.username_input)&#10;        passwordInput = findViewById(R.id.password_input)&#10;        loginBtn = findViewById(R.id.login_button)&#10;&#10;        loginBtn.setOnClickListener()&#10;        {&#10;            val email = usernameInput.text.toString();&#10;            val password = passwordInput.text.toString();&#10;&#10;            if (email.isEmpty() || password.isEmpty()) {&#10;                Toast.makeText(this, &quot;Please fill all fields&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            val user = databaseHelper.authenticateUser(email, password)&#10;            if (user != null) {&#10;                // Login successful&#10;                Toast.makeText(this, &quot;Welcome ${user.name}!&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                // Save user session&#10;                saveUserSession(user)&#10;&#10;                // Navigate to main activity&#10;                val intent = Intent(this, RestaurantViewActivity::class.java)&#10;                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                startActivity(intent)&#10;                finish()&#10;            } else {&#10;                Toast.makeText(this, &quot;Invalid email or password&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveUserSession(user: com.test.project.database.User) {&#10;        val sharedPref = getSharedPreferences(&quot;user_session&quot;, MODE_PRIVATE)&#10;        sharedPref.edit() {&#10;            putString(&quot;user_name&quot;, user.name)&#10;            putString(&quot;user_email&quot;, user.email)&#10;            putBoolean(&quot;is_logged_in&quot;, true)&#10;        }&#10;    }&#10;&#10;    private fun isUserLoggedIn(): Boolean {&#10;        val sharedPref = getSharedPreferences(&quot;user_session&quot;, MODE_PRIVATE)&#10;        return sharedPref.getBoolean(&quot;is_logged_in&quot;, false)&#10;    }&#10;&#10;&#10;}" />
              <option name="updatedContent" value="package com.test.project&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.test.project.database.DatabaseHelper&#10;import org.mindrot.jbcrypt.BCrypt&#10;import androidx.core.content.edit&#10;&#10;class LoginPageActivity : AppCompatActivity()&#10;{&#10;    lateinit var usernameInput : EditText&#10;    lateinit var passwordInput : EditText&#10;    lateinit var loginBtn : Button&#10;&#10;    lateinit var databaseHelper: DatabaseHelper&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?)&#10;    {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Check if user is already logged in&#10;        if (isUserLoggedIn()) {&#10;            val intent = Intent(this, RestaurantViewActivity::class.java)&#10;            startActivity(intent)&#10;            finish()&#10;            return&#10;        }&#10;&#10;        setContentView(R.layout.activity_login_page)&#10;&#10;        databaseHelper = DatabaseHelper(this)&#10;&#10;        usernameInput = findViewById(R.id.username_input)&#10;        passwordInput = findViewById(R.id.password_input)&#10;        loginBtn = findViewById(R.id.login_button)&#10;&#10;        loginBtn.setOnClickListener()&#10;        {&#10;            val email = usernameInput.text.toString();&#10;            val password = passwordInput.text.toString();&#10;&#10;            if (email.isEmpty() || password.isEmpty()) {&#10;                Toast.makeText(this, &quot;Please fill all fields&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            val user = databaseHelper.authenticateUser(email, password)&#10;            if (user != null) {&#10;                // Login successful&#10;                Toast.makeText(this, &quot;Welcome ${user.name}!&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                // Save user session&#10;                saveUserSession(user)&#10;&#10;                // Navigate to main activity&#10;                val intent = Intent(this, RestaurantViewActivity::class.java)&#10;                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                startActivity(intent)&#10;                finish()&#10;            } else {&#10;                Toast.makeText(this, &quot;Invalid email or password&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveUserSession(user: com.test.project.database.User) {&#10;        val sharedPref = getSharedPreferences(&quot;user_session&quot;, MODE_PRIVATE)&#10;        sharedPref.edit() {&#10;            putString(&quot;user_name&quot;, user.name)&#10;            putString(&quot;user_email&quot;, user.email)&#10;            putBoolean(&quot;is_logged_in&quot;, true)&#10;        }&#10;    }&#10;&#10;    private fun isUserLoggedIn(): Boolean {&#10;        val sharedPref = getSharedPreferences(&quot;user_session&quot;, MODE_PRIVATE)&#10;        return sharedPref.getBoolean(&quot;is_logged_in&quot;, false)&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/test/project/OrderAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/test/project/OrderAdapter.kt" />
              <option name="originalContent" value="package com.test.project&#10;&#10;import android.content.Intent&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.cardview.widget.CardView&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.test.project.database.Order&#10;&#10;class OrderAdapter(&#10;    private val orders: MutableList&lt;Order&gt;,&#10;    private val onOrderClick: (Order) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OrderAdapter.OrderViewHolder&gt;() {&#10;&#10;    fun updateOrders(newOrders: List&lt;Order&gt;) {&#10;        orders.clear()&#10;        orders.addAll(newOrders)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): OrderViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_order, parent, false)&#10;        return OrderViewHolder(view)&#10;    }&#10;&#10;    override fun getItemCount(): Int = orders.size&#10;&#10;    override fun onBindViewHolder(holder: OrderViewHolder, position: Int) {&#10;        holder.bind(orders[position])&#10;    }&#10;&#10;    inner class OrderViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val card: CardView = itemView as CardView&#10;        private val restaurantName: TextView = itemView.findViewById(R.id.orderRestaurantName)&#10;        private val orderId: TextView = itemView.findViewById(R.id.orderIdText)&#10;        private val itemsCount: TextView = itemView.findViewById(R.id.orderItemsCount)&#10;        private val totalPrice: TextView = itemView.findViewById(R.id.orderTotalPrice)&#10;&#10;        fun bind(order: Order) {&#10;            // Placeholder values - you will populate these with real data from DB&#10;            restaurantName.text = &quot;Restaurant #${order.restaurantId}&quot;&#10;            orderId.text = &quot;#${order.orderId}&quot;&#10;            itemsCount.text = &quot;? items&quot; // You'll fetch this from DB&#10;            totalPrice.text = &quot;Total: €?.??&quot; // You'll calculate this from DB&#10;&#10;            card.setOnClickListener {&#10;                onOrderClick(order)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.test.project&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.cardview.widget.CardView&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.test.project.database.DatabaseHelper&#10;import com.test.project.database.Order&#10;&#10;class OrderAdapter(&#10;    private val orders: MutableList&lt;Order&gt;,&#10;    private val onOrderClick: (Order) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OrderAdapter.OrderViewHolder&gt;() {&#10;&#10;    private lateinit var databaseHelper: DatabaseHelper&#10;&#10;    fun updateOrders(newOrders: List&lt;Order&gt;) {&#10;        orders.clear()&#10;        orders.addAll(newOrders)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): OrderViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_order, parent, false)&#10;        databaseHelper = DatabaseHelper(parent.context)&#10;        return OrderViewHolder(view)&#10;    }&#10;&#10;    override fun getItemCount(): Int = orders.size&#10;&#10;    override fun onBindViewHolder(holder: OrderViewHolder, position: Int) {&#10;        holder.bind(orders[position])&#10;    }&#10;&#10;    inner class OrderViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val card: CardView = itemView as CardView&#10;        private val restaurantName: TextView = itemView.findViewById(R.id.orderRestaurantName)&#10;        private val orderId: TextView = itemView.findViewById(R.id.orderIdText)&#10;        private val itemsCount: TextView = itemView.findViewById(R.id.orderItemsCount)&#10;        private val totalPrice: TextView = itemView.findViewById(R.id.orderTotalPrice)&#10;&#10;        fun bind(order: Order) {&#10;            val orderIdValue = order.orderId ?: 0&#10;            val restaurantIdValue = order.restaurantId&#10;            &#10;            // Get restaurant name&#10;            val restaurant = databaseHelper.getRestaurantById(restaurantIdValue)&#10;            restaurantName.text = restaurant?.name ?: &quot;Restaurant&quot;&#10;            &#10;            // Order ID&#10;            orderId.text = &quot;#$orderIdValue&quot;&#10;            &#10;            // Items count&#10;            val count = databaseHelper.getOrderItemsCount(orderIdValue)&#10;            itemsCount.text = if (count == 1) &quot;1 item&quot; else &quot;$count items&quot;&#10;            &#10;            // Total price&#10;            val total = databaseHelper.getOrderTotal(orderIdValue)&#10;            totalPrice.text = String.format(&quot;Total: €%.2f&quot;, total)&#10;&#10;            card.setOnClickListener {&#10;                onOrderClick(order)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/test/project/OrderDetailActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/test/project/OrderDetailActivity.kt" />
              <option name="originalContent" value="package com.test.project&#10;&#10;import android.os.Bundle&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.test.project.database.DatabaseHelper&#10;import com.test.project.database.Dish&#10;&#10;class OrderDetailActivity : AppCompatActivity() {&#10;&#10;    private lateinit var databaseHelper: DatabaseHelper&#10;    private lateinit var orderElementAdapter: OrderElementAdapter&#10;    private lateinit var orderItemsRecyclerView: RecyclerView&#10;    private lateinit var orderTotalText: TextView&#10;    private var orderId: Int? = null&#10;    private var restaurantId: Int? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_order_detail)&#10;&#10;        // Initialize database&#10;        databaseHelper = DatabaseHelper(this)&#10;&#10;        // Get order info from intent&#10;        orderId = intent.getIntExtra(&quot;ORDER_ID&quot;, -1)&#10;        restaurantId = intent.getIntExtra(&quot;RESTAURANT_ID&quot;, -1)&#10;&#10;        // Initialize views&#10;        val backButton: ImageButton = findViewById(R.id.backButton)&#10;        val orderTitleText: TextView = findViewById(R.id.orderTitleText)&#10;        val restaurantNameText: TextView = findViewById(R.id.restaurantNameText)&#10;        val orderIdDetailText: TextView = findViewById(R.id.orderIdDetailText)&#10;        orderItemsRecyclerView = findViewById(R.id.orderItemsRecyclerView)&#10;        orderTotalText = findViewById(R.id.orderTotalText)&#10;&#10;        // Set order info&#10;        orderIdDetailText.text = &quot;Order #$orderId&quot;&#10;&#10;        // TODO: Get restaurant name from DB&#10;        // val restaurant = databaseHelper.getRestaurantById(restaurantId!!)&#10;        restaurantNameText.text = &quot;Restaurant #$restaurantId&quot;&#10;&#10;        // Setup RecyclerView&#10;        setupRecyclerView()&#10;&#10;        // Load order items&#10;        loadOrderItems()&#10;&#10;        // Back button&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        orderElementAdapter = OrderElementAdapter(mutableListOf()) { dish, position -&gt;&#10;            showDeleteConfirmDialog(dish, position)&#10;        }&#10;&#10;        orderItemsRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@OrderDetailActivity)&#10;            adapter = orderElementAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadOrderItems() {&#10;        val orderIdValue = orderId ?: return&#10;&#10;        // TODO: Implement getOrderItems in DatabaseHelper&#10;        // This should return List&lt;Dish&gt; for the given orderId&#10;        val dishes = emptyList&lt;Dish&gt;() // databaseHelper.getOrderItems(orderIdValue)&#10;&#10;        orderElementAdapter.updateDishes(dishes)&#10;        updateTotal(dishes)&#10;    }&#10;&#10;    private fun showDeleteConfirmDialog(dish: Dish, position: Int) {&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Remove Item&quot;)&#10;            .setMessage(&quot;Remove ${dish.name} from your order?&quot;)&#10;            .setPositiveButton(&quot;Remove&quot;) { _, _ -&gt;&#10;                deleteOrderItem(dish, position)&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;&#10;    private fun deleteOrderItem(dish: Dish, position: Int) {&#10;        val orderIdValue = orderId ?: return&#10;        val dishId = dish.id ?: return&#10;&#10;        // TODO: Implement deleteOrderElement in DatabaseHelper&#10;        // val success = databaseHelper.deleteOrderElement(orderIdValue, dishId)&#10;&#10;        val success = true // Placeholder&#10;&#10;        if (success) {&#10;            orderElementAdapter.removeItem(position)&#10;            Toast.makeText(this, &quot;${dish.name} removed&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;            // Reload to update total&#10;            loadOrderItems()&#10;        } else {&#10;            Toast.makeText(this, &quot;Failed to remove item&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun updateTotal(dishes: List&lt;Dish&gt;) {&#10;        val total = dishes.sumOf { it.price }&#10;        orderTotalText.text = String.format(&quot;€%.2f&quot;, total)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        loadOrderItems()&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.test.project&#10;&#10;import android.os.Bundle&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.test.project.database.DatabaseHelper&#10;import com.test.project.database.Dish&#10;&#10;class OrderDetailActivity : AppCompatActivity() {&#10;&#10;    private lateinit var databaseHelper: DatabaseHelper&#10;    private lateinit var orderElementAdapter: OrderElementAdapter&#10;    private lateinit var orderItemsRecyclerView: RecyclerView&#10;    private lateinit var orderTotalText: TextView&#10;    private var orderId: Int? = null&#10;    private var restaurantId: Int? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_order_detail)&#10;&#10;        // Initialize database&#10;        databaseHelper = DatabaseHelper(this)&#10;&#10;        // Get order info from intent&#10;        orderId = intent.getIntExtra(&quot;ORDER_ID&quot;, -1)&#10;        restaurantId = intent.getIntExtra(&quot;RESTAURANT_ID&quot;, -1)&#10;&#10;        // Initialize views&#10;        val backButton: ImageButton = findViewById(R.id.backButton)&#10;        val orderTitleText: TextView = findViewById(R.id.orderTitleText)&#10;        val restaurantNameText: TextView = findViewById(R.id.restaurantNameText)&#10;        val orderIdDetailText: TextView = findViewById(R.id.orderIdDetailText)&#10;        orderItemsRecyclerView = findViewById(R.id.orderItemsRecyclerView)&#10;        orderTotalText = findViewById(R.id.orderTotalText)&#10;&#10;        // Set order info&#10;        orderIdDetailText.text = &quot;Order #$orderId&quot;&#10;        &#10;        // Get restaurant name from DB&#10;        val restaurant = databaseHelper.getRestaurantById(restaurantId!!)&#10;        restaurantNameText.text = restaurant?.name ?: &quot;Restaurant&quot;&#10;&#10;        // Setup RecyclerView&#10;        setupRecyclerView()&#10;&#10;        // Load order items&#10;        loadOrderItems()&#10;&#10;        // Back button&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        orderElementAdapter = OrderElementAdapter(mutableListOf()) { dish, position -&gt;&#10;            showDeleteConfirmDialog(dish, position)&#10;        }&#10;&#10;        orderItemsRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@OrderDetailActivity)&#10;            adapter = orderElementAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadOrderItems() {&#10;        val orderIdValue = orderId ?: return&#10;        &#10;        val dishes = databaseHelper.getOrderItems(orderIdValue)&#10;        &#10;        orderElementAdapter.updateDishes(dishes)&#10;        updateTotal(dishes)&#10;    }&#10;&#10;    private fun showDeleteConfirmDialog(dish: Dish, position: Int) {&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Remove Item&quot;)&#10;            .setMessage(&quot;Remove ${dish.name} from your order?&quot;)&#10;            .setPositiveButton(&quot;Remove&quot;) { _, _ -&gt;&#10;                deleteOrderItem(dish, position)&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;&#10;    private fun deleteOrderItem(dish: Dish, position: Int) {&#10;        val orderIdValue = orderId ?: return&#10;        val dishId = dish.id ?: return&#10;        &#10;        val success = databaseHelper.removeDishFromOrder(orderIdValue, dishId)&#10;        &#10;        if (success) {&#10;            orderElementAdapter.removeItem(position)&#10;            Toast.makeText(this, &quot;${dish.name} removed&quot;, Toast.LENGTH_SHORT).show()&#10;            &#10;            // Reload to update total&#10;            loadOrderItems()&#10;        } else {&#10;            Toast.makeText(this, &quot;Failed to remove item&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun updateTotal(dishes: List&lt;Dish&gt;) {&#10;        val total = dishes.sumOf { it.price }&#10;        orderTotalText.text = String.format(&quot;€%.2f&quot;, total)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        loadOrderItems()&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/test/project/OrdersViewActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/test/project/OrdersViewActivity.kt" />
              <option name="originalContent" value="package com.test.project&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.View&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.test.project.database.DatabaseHelper&#10;import com.test.project.database.Order&#10;&#10;class OrdersViewActivity : AppCompatActivity() {&#10;&#10;    private lateinit var databaseHelper: DatabaseHelper&#10;    private lateinit var orderAdapter: OrderAdapter&#10;    private lateinit var ordersRecyclerView: RecyclerView&#10;    private lateinit var emptyStateLayout: LinearLayout&#10;    private var currentUserId: Int? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_orders_view)&#10;&#10;        // Initialize database&#10;        databaseHelper = DatabaseHelper(this)&#10;&#10;        // Get current user ID&#10;        currentUserId = getCurrentUserId()&#10;&#10;        // Initialize views&#10;        val backButton: ImageButton = findViewById(R.id.backButton)&#10;        ordersRecyclerView = findViewById(R.id.ordersRecyclerView)&#10;        emptyStateLayout = findViewById(R.id.emptyStateLayout)&#10;&#10;        // Setup RecyclerView&#10;        setupRecyclerView()&#10;&#10;        // Load orders&#10;        loadOrders()&#10;&#10;        // Back button&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun getCurrentUserId(): Int? {&#10;        val sharedPref = getSharedPreferences(&quot;user_session&quot;, MODE_PRIVATE)&#10;        val isLoggedIn = sharedPref.getBoolean(&quot;is_logged_in&quot;, false)&#10;        if (!isLoggedIn) return null&#10;&#10;        val userEmail = sharedPref.getString(&quot;user_email&quot;, null) ?: return null&#10;        val user = databaseHelper.getUserByEmail(userEmail)&#10;        return user?.id&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        orderAdapter = OrderAdapter(mutableListOf()) { order -&gt;&#10;            // Navigate to order detail&#10;            val intent = Intent(this, OrderDetailActivity::class.java)&#10;            intent.putExtra(&quot;ORDER_ID&quot;, order.orderId)&#10;            intent.putExtra(&quot;RESTAURANT_ID&quot;, order.restaurantId)&#10;            startActivity(intent)&#10;        }&#10;&#10;        ordersRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@OrdersViewActivity)&#10;            adapter = orderAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadOrders() {&#10;        val userId = currentUserId ?: return&#10;&#10;        // TODO: Implement getAllOrdersForUser in DatabaseHelper&#10;        // For now, using empty list as placeholder&#10;        val orders = emptyList&lt;Order&gt;() // databaseHelper.getAllOrdersForUser(userId)&#10;&#10;        if (orders.isEmpty()) {&#10;            ordersRecyclerView.visibility = View.GONE&#10;            emptyStateLayout.visibility = View.VISIBLE&#10;        } else {&#10;            ordersRecyclerView.visibility = View.VISIBLE&#10;            emptyStateLayout.visibility = View.GONE&#10;            orderAdapter.updateOrders(orders)&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        loadOrders()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.test.project&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.View&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.test.project.database.DatabaseHelper&#10;import com.test.project.database.Order&#10;&#10;class OrdersViewActivity : AppCompatActivity() {&#10;&#10;    private lateinit var databaseHelper: DatabaseHelper&#10;    private lateinit var orderAdapter: OrderAdapter&#10;    private lateinit var ordersRecyclerView: RecyclerView&#10;    private lateinit var emptyStateLayout: LinearLayout&#10;    private var currentUserId: Int? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_orders_view)&#10;&#10;        // Initialize database&#10;        databaseHelper = DatabaseHelper(this)&#10;&#10;        // Get current user ID&#10;        currentUserId = getCurrentUserId()&#10;&#10;        // Initialize views&#10;        val backButton: ImageButton = findViewById(R.id.backButton)&#10;        ordersRecyclerView = findViewById(R.id.ordersRecyclerView)&#10;        emptyStateLayout = findViewById(R.id.emptyStateLayout)&#10;&#10;        // Setup RecyclerView&#10;        setupRecyclerView()&#10;&#10;        // Load orders&#10;        loadOrders()&#10;&#10;        // Back button&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun getCurrentUserId(): Int? {&#10;        val sharedPref = getSharedPreferences(&quot;user_session&quot;, MODE_PRIVATE)&#10;        val isLoggedIn = sharedPref.getBoolean(&quot;is_logged_in&quot;, false)&#10;        if (!isLoggedIn) return null&#10;&#10;        val userEmail = sharedPref.getString(&quot;user_email&quot;, null) ?: return null&#10;        val user = databaseHelper.getUserByEmail(userEmail)&#10;        return user?.id&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        orderAdapter = OrderAdapter(mutableListOf()) { order -&gt;&#10;            // Navigate to order detail&#10;            val intent = Intent(this, OrderDetailActivity::class.java)&#10;            intent.putExtra(&quot;ORDER_ID&quot;, order.orderId)&#10;            intent.putExtra(&quot;RESTAURANT_ID&quot;, order.restaurantId)&#10;            startActivity(intent)&#10;        }&#10;&#10;        ordersRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@OrdersViewActivity)&#10;            adapter = orderAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadOrders() {&#10;        val userId = currentUserId ?: return&#10;        &#10;        val orders = databaseHelper.getOrdersForUser(userId)&#10;        &#10;        if (orders.isEmpty()) {&#10;            ordersRecyclerView.visibility = View.GONE&#10;            emptyStateLayout.visibility = View.VISIBLE&#10;        } else {&#10;            ordersRecyclerView.visibility = View.VISIBLE&#10;            emptyStateLayout.visibility = View.GONE&#10;            orderAdapter.updateOrders(orders)&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        loadOrders()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/test/project/RestaurantMenuActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/test/project/RestaurantMenuActivity.kt" />
              <option name="originalContent" value="package com.test.project&#10;&#10;import android.os.Bundle&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.test.project.database.Dish&#10;import com.test.project.database.DatabaseHelper&#10;&#10;class RestaurantMenuActivity : AppCompatActivity() {&#10;&#10;    private lateinit var backButton: ImageButton&#10;    private lateinit var restaurantNameToolbar: TextView&#10;    private lateinit var menuRecyclerView: RecyclerView&#10;    private lateinit var dishAdapter: DishAdapter&#10;    private lateinit var databaseHelper: DatabaseHelper&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_restaurant_menu)&#10;&#10;        // Initialize database helper&#10;        databaseHelper = DatabaseHelper(this)&#10;&#10;        // Initialize views&#10;        initViews()&#10;&#10;        // Get restaurant name from intent&#10;        val restaurantName = intent.getStringExtra(&quot;RESTAURANT_NAME&quot;) ?: &quot;Restaurant Menu&quot;&#10;        restaurantNameToolbar.text = restaurantName&#10;&#10;        // Setup RecyclerView&#10;        setupRecyclerView()&#10;&#10;        // Load menu data from database&#10;        loadMenuData(restaurantName)&#10;&#10;        // Setup click listeners&#10;        setupClickListeners()&#10;    }&#10;&#10;    private fun initViews() {&#10;        backButton = findViewById(R.id.backButton)&#10;        restaurantNameToolbar = findViewById(R.id.restaurantNameToolbar)&#10;        menuRecyclerView = findViewById(R.id.menuRecyclerView)&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        dishAdapter = DishAdapter(emptyList()) { dish -&gt;&#10;            // dish click - for now, just show a toast&#10;            android.widget.Toast.makeText(&#10;                this,&#10;                &quot;Selected: ${dish.name}&quot;,&#10;                android.widget.Toast.LENGTH_SHORT&#10;            ).show()&#10;        }&#10;&#10;        menuRecyclerView.apply {&#10;            adapter = dishAdapter&#10;            layoutManager = LinearLayoutManager(this@RestaurantMenuActivity)&#10;        }&#10;    }&#10;&#10;    private fun loadMenuData(restaurantName: String) {&#10;        val dishes = databaseHelper.getMenuForRestaurant(restaurantName)&#10;        dishAdapter.updateDishes(dishes)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.test.project&#10;&#10;import android.os.Bundle&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.test.project.database.Dish&#10;import com.test.project.database.DatabaseHelper&#10;&#10;class RestaurantMenuActivity : AppCompatActivity() {&#10;&#10;    private lateinit var backButton: ImageButton&#10;    private lateinit var restaurantNameToolbar: TextView&#10;    private lateinit var menuRecyclerView: RecyclerView&#10;    private lateinit var dishAdapter: DishAdapter&#10;    private lateinit var databaseHelper: DatabaseHelper&#10;    private var currentUserId: Int? = null&#10;    private var currentRestaurantId: Int? = null&#10;    private var currentRestaurantName: String = &quot;&quot;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_restaurant_menu)&#10;&#10;        // Initialize database helper&#10;        databaseHelper = DatabaseHelper(this)&#10;&#10;        // Get current user ID&#10;        currentUserId = getCurrentUserId()&#10;&#10;        // Initialize views&#10;        initViews()&#10;&#10;        // Get restaurant name from intent&#10;        currentRestaurantName = intent.getStringExtra(&quot;RESTAURANT_NAME&quot;) ?: &quot;Restaurant Menu&quot;&#10;        restaurantNameToolbar.text = currentRestaurantName&#10;&#10;        // Get restaurant ID from name&#10;        val restaurant = databaseHelper.getRestaurantByName(currentRestaurantName)&#10;        currentRestaurantId = restaurant?.id&#10;&#10;        // Setup RecyclerView&#10;        setupRecyclerView()&#10;&#10;        // Load menu data from database&#10;        loadMenuData(currentRestaurantName)&#10;&#10;        // Setup click listeners&#10;        setupClickListeners()&#10;    }&#10;&#10;    private fun getCurrentUserId(): Int? {&#10;        val sharedPref = getSharedPreferences(&quot;user_session&quot;, MODE_PRIVATE)&#10;        val isLoggedIn = sharedPref.getBoolean(&quot;is_logged_in&quot;, false)&#10;        if (!isLoggedIn) return null&#10;&#10;        val userEmail = sharedPref.getString(&quot;user_email&quot;, null) ?: return null&#10;        val user = databaseHelper.getUserByEmail(userEmail)&#10;        return user?.id&#10;    }&#10;&#10;    private fun initViews() {&#10;        backButton = findViewById(R.id.backButton)&#10;        restaurantNameToolbar = findViewById(R.id.restaurantNameToolbar)&#10;        menuRecyclerView = findViewById(R.id.menuRecyclerView)&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        dishAdapter = DishAdapter(emptyList()) { dish -&gt;&#10;            // Dish click - add to order&#10;            addDishToOrder(dish)&#10;        }&#10;&#10;        menuRecyclerView.apply {&#10;            adapter = dishAdapter&#10;            layoutManager = LinearLayoutManager(this@RestaurantMenuActivity)&#10;        }&#10;    }&#10;&#10;    private fun loadMenuData(restaurantName: String) {&#10;        val dishes = databaseHelper.getMenuForRestaurant(restaurantName)&#10;        dishAdapter.updateDishes(dishes)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun addDishToOrder(dish: Dish) {&#10;        val userId = currentUserId&#10;        val restaurantId = currentRestaurantId&#10;        val dishId = dish.id&#10;&#10;        // Check if user is logged in&#10;        if (userId == null) {&#10;            Toast.makeText(this, &quot;Please log in to add items to your order&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        if (restaurantId == null || dishId == null) {&#10;            Toast.makeText(this, &quot;Error: Invalid restaurant or dish&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Get or create order&#10;        val orderId = databaseHelper.getOrCreateOrder(userId, restaurantId)&#10;&#10;        if (orderId == null) {&#10;            Toast.makeText(this, &quot;Failed to create order&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Add dish to order&#10;        val success = databaseHelper.addDishToOrder(orderId, dishId)&#10;&#10;        if (success) {&#10;            // Show success dialog&#10;            AlertDialog.Builder(this)&#10;                .setTitle(&quot;Added to Order&quot;)&#10;                .setMessage(&quot;${dish.name} has been added to your order!&quot;)&#10;                .setPositiveButton(&quot;OK&quot;, null)&#10;                .setNeutralButton(&quot;View Order&quot;) { _, _ -&gt;&#10;                    // Navigate to order detail&#10;                    val intent = android.content.Intent(this, OrderDetailActivity::class.java)&#10;                    intent.putExtra(&quot;ORDER_ID&quot;, orderId)&#10;                    intent.putExtra(&quot;RESTAURANT_ID&quot;, restaurantId)&#10;                    startActivity(intent)&#10;                }&#10;                .show()&#10;        } else {&#10;            Toast.makeText(this, &quot;Failed to add item to order&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/test/project/database/DatabaseHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/test/project/database/DatabaseHelper.kt" />
              <option name="originalContent" value="package com.test.project.database&#10;&#10;import android.content.Context&#10;import android.database.sqlite.SQLiteDatabase&#10;import android.database.sqlite.SQLiteOpenHelper&#10;&#10;import org.mindrot.jbcrypt.BCrypt&#10;&#10;class DatabaseHelper(&#10;    context: Context,&#10;) : SQLiteOpenHelper(&#10;    context,&#10;    &quot;project.db&quot;,&#10;    null,&#10;    7&#10;) {&#10;    override fun onCreate(db: SQLiteDatabase?) {&#10;        // Create Users table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS users (&#10;                id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                name TEXT NOT NULL,&#10;                email TEXT NOT NULL UNIQUE,&#10;                passwordHash TEXT NOT NULL,&#10;                salt TEXT NOT NULL&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Restaurants table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS restaurants (&#10;                id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                name TEXT NOT NULL,&#10;                address TEXT NOT NULL,&#10;                phoneNumber TEXT NOT NULL,&#10;                description TEXT,&#10;                shortDescription TEXT,&#10;                rating REAL,&#10;                videoUri TEXT,&#10;                image1Uri TEXT,&#10;                image2Uri TEXT&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Dishes table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS dishes (&#10;                id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                name TEXT NOT NULL,&#10;                description TEXT NOT NULL,&#10;                price REAL NOT NULL,&#10;                imageUrl TEXT&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Orders table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS orders (&#10;                orderId INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                userId INTEGER NOT NULL,&#10;                restaurantId INTEGER NOT NULL,&#10;                FOREIGN KEY (userId) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE,&#10;                FOREIGN KEY (restaurantId) REFERENCES restaurants(id) ON UPDATE CASCADE ON DELETE CASCADE&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create OrderElements table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS order_elements (&#10;                orderId INTEGER NOT NULL,&#10;                dishId INTEGER NOT NULL,&#10;                PRIMARY KEY (orderId, dishId),&#10;                FOREIGN KEY (orderId) REFERENCES orders(orderId) ON UPDATE CASCADE ON DELETE CASCADE,&#10;                FOREIGN KEY (dishId) REFERENCES dishes(id) ON UPDATE CASCADE ON DELETE CASCADE&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Reviews table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS reviews (&#10;                userId INTEGER NOT NULL,&#10;                restaurantId INTEGER NOT NULL,&#10;                rating REAL NOT NULL,&#10;                comment TEXT,&#10;                PRIMARY KEY (userId, restaurantId),&#10;                FOREIGN KEY (userId) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE,&#10;                FOREIGN KEY (restaurantId) REFERENCES restaurants(id) ON UPDATE CASCADE ON DELETE CASCADE&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Menu Elements table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS menu_elements (&#10;                restaurantId INTEGER NOT NULL,&#10;                dishId INTEGER NOT NULL,&#10;                PRIMARY KEY (restaurantId, dishId),&#10;                FOREIGN KEY (restaurantId) REFERENCES restaurants(id) ON UPDATE CASCADE ON DELETE CASCADE,&#10;                FOREIGN KEY (dishId) REFERENCES dishes(id) ON UPDATE CASCADE ON DELETE CASCADE&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // insert premade data&#10;        insertPremadeUsers(db)&#10;        insertPremadeRestaurants(db)&#10;        insertPremadeDishes(db)&#10;        insertPremadeReviews(db)&#10;    }&#10;&#10;    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {&#10;        insertPremadeRestaurants(db)&#10;        // For major version changes, drop and recreate&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS menu_elements&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS reviews&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS order_elements&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS orders&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS dishes&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS restaurants&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS users&quot;)&#10;        onCreate(db)&#10;&#10;        insertPremadeRestaurants(db)&#10;    }&#10;&#10;&#10;    // example dishes&#10;    private  fun insertPremadeDishes(db: SQLiteDatabase?) {&#10;        val dishes = listOf(&#10;            Dish(&#10;                name = &quot;Margherita Pizza&quot;,&#10;                description = &quot;Classic pizza with tomato sauce, mozzarella cheese, and fresh basil&quot;,&#10;                price = 12.50&#10;            ),&#10;            Dish(&#10;                name = &quot;Spaghetti Carbonara&quot;,&#10;                description = &quot;Traditional Italian pasta with eggs, cheese, pancetta, and black pepper&quot;,&#10;                price = 14.00&#10;            ),&#10;            Dish(&#10;                name = &quot;Caesar Salad&quot;,&#10;                description = &quot;Fresh romaine lettuce, parmesan cheese, croutons with caesar dressing&quot;,&#10;                price = 9.50&#10;            ),&#10;            Dish(&#10;                name = &quot;Grilled Salmon&quot;,&#10;                description = &quot;Fresh salmon fillet grilled to perfection with lemon and herbs&quot;,&#10;                price = 18.00&#10;            ),&#10;            Dish(&#10;                name = &quot;Tiramisu&quot;,&#10;                description = &quot;Classic Italian dessert with coffee-soaked ladyfingers and mascarpone&quot;,&#10;                price = 6.50&#10;            ),&#10;            Dish(&#10;                name = &quot;Bruschetta&quot;,&#10;                description = &quot;Grilled bread topped with fresh tomatoes, garlic, and basil&quot;,&#10;                price = 7.00&#10;            ),&#10;            Dish(&#10;                name = &quot;Risotto ai Funghi&quot;,&#10;                description = &quot;Creamy rice dish with mixed mushrooms and parmesan cheese&quot;,&#10;                price = 15.50&#10;            ),&#10;            Dish(&#10;                name = &quot;Gelato&quot;,&#10;                description = &quot;Italian ice cream available in various flavors&quot;,&#10;                price = 4.50&#10;            )&#10;        )&#10;&#10;        dishes.forEach { dish -&gt;&#10;            db?.insert(&quot;dishes&quot;, null, dish.toContentValues())&#10;        }&#10;&#10;        // link dishes to restaurants in menu_elements table&#10;        val menuElements = listOf(&#10;            Pair(1, 1), // Spaghetti Carbonara to Symposium Cafe&#10;            Pair(1, 2), // Margherita Pizza to Symposium Cafe&#10;            Pair(2, 3),  // Caesar Salad to The Keg Oshawa&#10;            Pair(3, 4), // Grilled Salmon to Fazio's Italian Restaurant&#10;            Pair(3, 5), // Tiramisu to Fazio's Italian Restaurant&#10;            Pair(4, 6), // Bruschetta to Sushi Masa Japanese Restaurant&#10;            Pair(5, 7), // Risotto ai Funghi to Oshawa House Restaurant&#10;            Pair(5, 8)  // Gelato to Oshawa House Restaurant&#10;        )&#10;&#10;        menuElements.forEach { (restaurantId, dishId) -&gt;&#10;            val contentValues = android.content.ContentValues().apply {&#10;                put(&quot;restaurantId&quot;, restaurantId)&#10;                put(&quot;dishId&quot;, dishId)&#10;            }&#10;            db?.insert(&quot;menu_elements&quot;, null, contentValues)&#10;        }&#10;    }&#10;&#10;    // example restaurants&#10;    private fun insertPremadeRestaurants(db: SQLiteDatabase?) {&#10;        val restaurants = listOf(&#10;            Restaurant(&#10;                name = &quot;Symposium Cafe Restaurant &amp; Lounge&quot;,&#10;                description = &quot;A vibrant restaurant and lounge offering contemporary Canadian cuisine with international influences. Known for their extensive menu featuring everything from pasta and steaks to fresh salads and creative desserts. The atmosphere is warm and welcoming, perfect for both casual dining and special occasions.&quot;,&#10;                shortDescription = &quot;Contemporary Canadian cuisine&quot;,&#10;                rating = 0f,&#10;                address = &quot;1300 King St E, Oshawa, ON L1H 8J4&quot;,&#10;                phoneNumber = &quot;(905) 436-3354&quot;&#10;            ),&#10;            Restaurant(&#10;                name = &quot;The Keg Oshawa&quot;,&#10;                description = &quot;A classic steakhouse chain known for their premium steaks, fresh seafood, and signature caesar salads. The Keg offers a sophisticated dining experience with their dark wood decor and comfortable atmosphere. Their menu features AAA grade steaks, lobster, and an extensive wine selection.&quot;,&#10;                shortDescription = &quot;Premium steakhouse&quot;,&#10;                rating = 0f, // Will be calculated from reviews&#10;                address = &quot;1200 Thornton Rd N, Oshawa, ON L1H 7K4&quot;,&#10;                phoneNumber = &quot;(905) 433-3700&quot;&#10;            ),&#10;            Restaurant(&#10;                name = &quot;Fazio's Italian Restaurant&quot;,&#10;                description = &quot;Family-owned authentic Italian restaurant serving traditional recipes passed down through generations. Features homemade pasta, wood-fired pizza, and classic Italian entrees. The cozy atmosphere and friendly service make it feel like dining at an Italian family's home.&quot;,&#10;                shortDescription = &quot;Authentic Italian family dining&quot;,&#10;                rating = 0f, // Will be calculated from reviews&#10;                address = &quot;1668 Simcoe St N, Oshawa, ON L1G 4X6&quot;,&#10;                phoneNumber = &quot;(905) 436-3287&quot;&#10;            ),&#10;            Restaurant(&#10;                name = &quot;Sushi Masa Japanese Restaurant&quot;,&#10;                description = &quot;Fresh and authentic Japanese cuisine featuring expertly crafted sushi, sashimi, and traditional Japanese dishes. The chef uses only the finest ingredients to create beautiful presentations. The minimalist decor creates a peaceful dining environment perfect for enjoying the artistry of Japanese cuisine.&quot;,&#10;                shortDescription = &quot;Fresh authentic Japanese sushi&quot;,&#10;                rating = 0f, // Will be calculated from reviews&#10;                address = &quot;1300 King St E Unit 3, Oshawa, ON L1H 8J4&quot;,&#10;                phoneNumber = &quot;(905) 240-0888&quot;&#10;            ),&#10;            Restaurant(&#10;                name = &quot;Oshawa House Restaurant&quot;,&#10;                description = &quot;A local landmark serving comfort food and traditional favorites for over 30 years. Known for their generous portions, friendly service, and classic diner atmosphere. Popular for breakfast all day, hearty burgers, and homestyle dinners that remind you of home cooking.&quot;,&#10;                shortDescription = &quot;Classic comfort food diner&quot;,&#10;                rating = 0f, // Will be calculated from reviews&#10;                address = &quot;1425 King St E, Oshawa, ON L1H 8J6&quot;,&#10;                phoneNumber = &quot;(905) 579-4449&quot;&#10;            )&#10;        )&#10;&#10;        restaurants.forEach { restaurant -&gt;&#10;            db?.insert(&quot;restaurants&quot;, null, restaurant.toContentValues())&#10;        }&#10;    }&#10;&#10;    // insert premade users&#10;    private fun insertPremadeUsers(db: SQLiteDatabase?) {&#10;        if (db == null) return&#10;        &#10;        // Insert users directly during database creation to avoid recursion&#10;        val users = listOf(&#10;            Triple(&quot;Edoardo&quot;, &quot;edoardo.borlina@gmail.com&quot;, &quot;password&quot;),&#10;            Triple(&quot;Bralyn&quot;, &quot;bralynlp@gmail.com&quot;, &quot;password123&quot;),&#10;            Triple(&quot;User&quot;, &quot;user.example@email.com&quot;, &quot;password&quot;)&#10;        )&#10;        &#10;        users.forEach { (name, email, password) -&gt;&#10;            val salt = BCrypt.gensalt()&#10;            val passwordHash = BCrypt.hashpw(password, salt)&#10;            &#10;            val values = android.content.ContentValues().apply {&#10;                put(&quot;name&quot;, name)&#10;                put(&quot;email&quot;, email)&#10;                put(&quot;passwordHash&quot;, passwordHash)&#10;                put(&quot;salt&quot;, salt)&#10;            }&#10;            &#10;            db.insert(&quot;users&quot;, null, values)&#10;        }&#10;    }&#10;&#10;    // insert premade reviews&#10;    private fun insertPremadeReviews(db: SQLiteDatabase?) {&#10;        if (db == null) return&#10;&#10;        // Example reviews from different users&#10;        val reviews = listOf(&#10;            // Reviews for Symposium Cafe (restaurantId = 1)&#10;            Review(userId = 1, restaurantId = 1, rating = 4.0f, comment = &quot;Great atmosphere and delicious food!&quot;),&#10;            Review(userId = 2, restaurantId = 1, rating = 4.5f, comment = &quot;Love their desserts, highly recommended!&quot;),&#10;&#10;            // Reviews for The Keg Oshawa (restaurantId = 2)&#10;            Review(userId = 1, restaurantId = 2, rating = 5.0f, comment = &quot;Best steaks in town! Perfect cooking every time.&quot;),&#10;            Review(userId = 3, restaurantId = 2, rating = 4.0f, comment = &quot;Excellent service and quality meat.&quot;),&#10;&#10;            // Reviews for Fazio's Italian Restaurant (restaurantId = 3)&#10;            Review(userId = 2, restaurantId = 3, rating = 4.5f, comment = &quot;Authentic Italian cuisine, feels like home!&quot;),&#10;            Review(userId = 3, restaurantId = 3, rating = 5.0f, comment = &quot;The pasta is amazing, family-friendly atmosphere.&quot;),&#10;&#10;            // Reviews for Sushi Masa (restaurantId = 4)&#10;            Review(userId = 1, restaurantId = 4, rating = 4.5f, comment = &quot;Fresh sushi, beautiful presentation!&quot;),&#10;            Review(userId = 2, restaurantId = 4, rating = 4.0f, comment = &quot;Good quality fish, nice ambiance.&quot;),&#10;&#10;            // Reviews for Oshawa House Restaurant (restaurantId = 5)&#10;            Review(userId = 3, restaurantId = 5, rating = 4.0f, comment = &quot;Classic diner with great comfort food!&quot;)&#10;        )&#10;&#10;        reviews.forEach { review -&gt;&#10;            db.insert(&quot;reviews&quot;, null, review.toContentValues())&#10;        }&#10;&#10;        // Update restaurant ratings based on these reviews&#10;        for (restaurantId in 1..5) {&#10;            val avgRating = calculateAverageRatingFromDb(db, restaurantId)&#10;            val contentValues = android.content.ContentValues().apply {&#10;                put(&quot;rating&quot;, avgRating)&#10;            }&#10;            db.update(&quot;restaurants&quot;, contentValues, &quot;id = ?&quot;, arrayOf(restaurantId.toString()))&#10;        }&#10;    }&#10;&#10;    // Helper method to calculate average rating during onCreate (when db is being created)&#10;    private fun calculateAverageRatingFromDb(db: SQLiteDatabase, restaurantId: Int): Float {&#10;        val cursor = db.rawQuery(&#10;            &quot;SELECT AVG(rating) as avgRating FROM reviews WHERE restaurantId = ?&quot;,&#10;            arrayOf(restaurantId.toString())&#10;        )&#10;&#10;        var avgRating = 0f&#10;        if (cursor.moveToFirst()) {&#10;            val columnIndex = cursor.getColumnIndex(&quot;avgRating&quot;)&#10;            if (columnIndex != -1 &amp;&amp; !cursor.isNull(columnIndex)) {&#10;                avgRating = cursor.getFloat(columnIndex)&#10;            }&#10;        }&#10;        cursor.close()&#10;&#10;        return avgRating&#10;    }&#10;    /// Restaurants Table Methods&#10;&#10;    // Get all restaurants&#10;    fun getAllRestaurants(): List&lt;Restaurant&gt; {&#10;        val restaurants = mutableListOf&lt;Restaurant&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM restaurants&quot;, null)&#10;        while (cursor.moveToNext()) {&#10;            val restaurant: Restaurant = Restaurant.getFromCursor(cursor)&#10;            restaurants.add(restaurant)&#10;        }&#10;        cursor.close()&#10;        return restaurants&#10;    }&#10;&#10;    // insert a restaurant&#10;    fun insertRestaurant(restaurant: Restaurant){&#10;        val db = writableDatabase&#10;        db.insert(&quot;restaurants&quot;, null, restaurant.toContentValues())&#10;    }&#10;&#10;    // Update restaurant media (video and images)&#10;    fun updateRestaurantMedia(restaurantId: Int, videoUri: String?, image1Uri: String?, image2Uri: String?): Boolean {&#10;        val db = writableDatabase&#10;        val contentValues = android.content.ContentValues().apply {&#10;            put(&quot;videoUri&quot;, videoUri)&#10;            put(&quot;image1Uri&quot;, image1Uri)&#10;            put(&quot;image2Uri&quot;, image2Uri)&#10;        }&#10;        val result = db.update(&quot;restaurants&quot;, contentValues, &quot;id = ?&quot;, arrayOf(restaurantId.toString()))&#10;        return result &gt; 0&#10;    }&#10;&#10;&#10;    // Menu and Menu elements Methods&#10;    // Get menu for a restaurant given the name&#10;    fun getMenuForRestaurant(restaurantName: String): List&lt;Dish&gt; {&#10;        val dishes = mutableListOf&lt;Dish&gt;()&#10;        val db = readableDatabase&#10;        val query = &quot;&quot;&quot;&#10;            SELECT d.* FROM dishes d&#10;            JOIN menu_elements me ON d.id = me.dishId&#10;            JOIN restaurants r ON me.restaurantId = r.id&#10;            WHERE r.name = ?&#10;        &quot;&quot;&quot;&#10;        val cursor = db.rawQuery(query, arrayOf(restaurantName))&#10;        while (cursor.moveToNext()) {&#10;            val dish: Dish = Dish.getFromCursor(cursor)&#10;            dishes.add(dish)&#10;        }&#10;        cursor.close()&#10;        return dishes&#10;    }&#10;&#10;    // User Table Methods&#10;&#10;    // retrieve user by email&#10;    fun getUserByEmail(email: String): User? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM users WHERE email = ?&quot;, arrayOf(email))&#10;        var user: User? = null&#10;        if (cursor.moveToFirst()) {&#10;            user = User.getFromCursor(cursor)&#10;        }&#10;        cursor.close()&#10;        return user&#10;    }&#10;&#10;    // register user&#10;    fun registerUser(name: String, email: String, password: String): Boolean {&#10;        val db = writableDatabase&#10;&#10;        // check if user already exists&#10;        val existingUser = getUserByEmail(email)&#10;        if (existingUser != null) {&#10;            return false&#10;        }&#10;&#10;&#10;        val salt = BCrypt.gensalt()&#10;        val passwordHash = BCrypt.hashpw(password, salt)&#10;&#10;        val user = User(&#10;            name = name,&#10;            email = email,&#10;            passwordHash = passwordHash,&#10;            salt = salt&#10;        )&#10;&#10;        val result = db.insert(&quot;users&quot;, null, user.toContentValues())&#10;        return result != -1L&#10;    }&#10;&#10;    // autenticate userù&#10;    fun authenticateUser(email: String, password: String): User? {&#10;        val user = getUserByEmail(email) ?: return null&#10;&#10;        return if (BCrypt.checkpw(password, user.passwordHash)) {&#10;            user&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    // Review Methods&#10;&#10;    // Get all reviews for a restaurant&#10;    fun getReviewsForRestaurant(restaurantId: Int): List&lt;Review&gt; {&#10;        val reviews = mutableListOf&lt;Review&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM reviews WHERE restaurantId = ?&quot;, arrayOf(restaurantId.toString()))&#10;        while (cursor.moveToNext()) {&#10;            val review: Review = Review.getFromCursor(cursor)&#10;            reviews.add(review)&#10;        }&#10;        cursor.close()&#10;        return reviews&#10;    }&#10;&#10;    // Get review by user and restaurant (since user can only have one review per restaurant)&#10;    fun getUserReviewForRestaurant(userId: Int, restaurantId: Int): Review? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM reviews WHERE userId = ? AND restaurantId = ?&quot;,&#10;            arrayOf(userId.toString(), restaurantId.toString()))&#10;        var review: Review? = null&#10;        if (cursor.moveToFirst()) {&#10;            review = Review.getFromCursor(cursor)&#10;        }&#10;        cursor.close()&#10;        return review&#10;    }&#10;&#10;    // Insert or update a review (since user can only have one review per restaurant)&#10;    fun insertOrUpdateReview(review: Review): Boolean {&#10;        val db = writableDatabase&#10;        val result = db.insertWithOnConflict(&quot;reviews&quot;, null, review.toContentValues(),&#10;            android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE)&#10;&#10;        // Update restaurant rating after insertion/update&#10;        if (result != -1L) {&#10;            updateRestaurantRating(review.restaurantId)&#10;        }&#10;&#10;        return result != -1L&#10;    }&#10;&#10;    // Delete a review&#10;    fun deleteReview(userId: Int, restaurantId: Int): Boolean {&#10;        val db = writableDatabase&#10;        val result = db.delete(&quot;reviews&quot;, &quot;userId = ? AND restaurantId = ?&quot;,&#10;            arrayOf(userId.toString(), restaurantId.toString()))&#10;&#10;        // Update restaurant rating after deletion&#10;        if (result &gt; 0) {&#10;            updateRestaurantRating(restaurantId)&#10;        }&#10;&#10;        return result &gt; 0&#10;    }&#10;&#10;    // Calculate average rating for a restaurant&#10;    fun calculateAverageRating(restaurantId: Int): Float {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&#10;            &quot;SELECT AVG(rating) as avgRating FROM reviews WHERE restaurantId = ?&quot;,&#10;            arrayOf(restaurantId.toString())&#10;        )&#10;&#10;        var avgRating = 0f&#10;        if (cursor.moveToFirst()) {&#10;            val columnIndex = cursor.getColumnIndex(&quot;avgRating&quot;)&#10;            if (columnIndex != -1 &amp;&amp; !cursor.isNull(columnIndex)) {&#10;                avgRating = cursor.getFloat(columnIndex)&#10;            }&#10;        }&#10;        cursor.close()&#10;&#10;        return avgRating&#10;    }&#10;&#10;    // Update restaurant rating based on reviews&#10;    fun updateRestaurantRating(restaurantId: Int) {&#10;        val db = writableDatabase&#10;        val avgRating = calculateAverageRating(restaurantId)&#10;&#10;        val contentValues = android.content.ContentValues().apply {&#10;            put(&quot;rating&quot;, avgRating)&#10;        }&#10;&#10;        db.update(&quot;restaurants&quot;, contentValues, &quot;id = ?&quot;, arrayOf(restaurantId.toString()))&#10;    }&#10;&#10;    // Get restaurant by ID&#10;    fun getRestaurantById(restaurantId: Int): Restaurant? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM restaurants WHERE id = ?&quot;, arrayOf(restaurantId.toString()))&#10;        var restaurant: Restaurant? = null&#10;        if (cursor.moveToFirst()) {&#10;            restaurant = Restaurant.getFromCursor(cursor)&#10;        }&#10;        cursor.close()&#10;        return restaurant&#10;    }&#10;&#10;    // Get restaurant by name&#10;    fun getRestaurantByName(restaurantName: String): Restaurant? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM restaurants WHERE name = ?&quot;, arrayOf(restaurantName))&#10;        var restaurant: Restaurant? = null&#10;        if (cursor.moveToFirst()) {&#10;            restaurant = Restaurant.getFromCursor(cursor)&#10;        }&#10;        cursor.close()&#10;        return restaurant&#10;    }&#10;&#10;    // Get user name by ID&#10;    fun getUserNameById(userId: Int): String? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT name FROM users WHERE id = ?&quot;, arrayOf(userId.toString()))&#10;        var userName: String? = null&#10;        if (cursor.moveToFirst()) {&#10;            userName = cursor.getString(cursor.getColumnIndexOrThrow(&quot;name&quot;))&#10;        }&#10;        cursor.close()&#10;        return userName&#10;    }&#10;&#10;    /// Order &amp; Order element Methods&#10;&#10;    // create order&#10;    fun createOrder(userId: Int, restaurantId: Int, dishIds: List&lt;Int&gt;): Boolean {&#10;        val db = writableDatabase&#10;        db.beginTransaction()&#10;        return try {&#10;            // Insert order&#10;            val orderValues = android.content.ContentValues().apply {&#10;                put(&quot;userId&quot;, userId)&#10;                put(&quot;restaurantId&quot;, restaurantId)&#10;            }&#10;            val orderId = db.insert(&quot;orders&quot;, null, orderValues)&#10;            if (orderId == -1L) {&#10;                throw Exception(&quot;Failed to create order&quot;)&#10;            }&#10;&#10;            // Insert order elements&#10;            dishIds.forEach { dishId -&gt;&#10;                val orderElementValues = android.content.ContentValues().apply {&#10;                    put(&quot;orderId&quot;, orderId)&#10;                    put(&quot;dishId&quot;, dishId)&#10;                }&#10;                val result = db.insert(&quot;order_elements&quot;, null, orderElementValues)&#10;                if (result == -1L) {&#10;                    throw Exception(&quot;Failed to add dish $dishId to order&quot;)&#10;                }&#10;            }&#10;&#10;            db.setTransactionSuccessful()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        } finally {&#10;            db.endTransaction()&#10;        }&#10;    }&#10;&#10;    // Get orders for a user&#10;    fun getOrdersForUser(userId: Int): List&lt;Order&gt; {&#10;        val orders = mutableListOf&lt;Order&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM orders WHERE userId = ?&quot;, arrayOf(userId.toString()))&#10;        while (cursor.moveToNext()) {&#10;            val order: Order = Order.getFromCursor(cursor)&#10;            orders.add(order)&#10;        }&#10;        cursor.close()&#10;        return orders&#10;    }&#10;&#10;    // remove element from order&#10;    fun removeDishFromOrder(orderId: Int, dishId: Int): Boolean {&#10;        val db = writableDatabase&#10;        val result = db.delete(&quot;order_elements&quot;, &quot;orderId = ? AND dishId = ?&quot;,&#10;            arrayOf(orderId.toString(), dishId.toString()))&#10;        return result &gt; 0&#10;    }&#10;&#10;    // add element to order&#10;    fun addDishToOrder(orderId: Int, dishId: Int): Boolean {&#10;        val db = writableDatabase&#10;        val orderElementValues = OrderElement(&#10;            orderId = orderId,&#10;            dishId = dishId&#10;        ).toContentValues()&#10;        val result = db.insert(&quot;order_elements&quot;, null, orderElementValues)&#10;        return result != -1L&#10;    }&#10;&#10;&#10;&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.test.project.database&#10;&#10;import android.content.Context&#10;import android.database.sqlite.SQLiteDatabase&#10;import android.database.sqlite.SQLiteOpenHelper&#10;&#10;import org.mindrot.jbcrypt.BCrypt&#10;&#10;class DatabaseHelper(&#10;    context: Context,&#10;) : SQLiteOpenHelper(&#10;    context,&#10;    &quot;project.db&quot;,&#10;    null,&#10;    7&#10;) {&#10;    override fun onCreate(db: SQLiteDatabase?) {&#10;        // Create Users table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS users (&#10;                id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                name TEXT NOT NULL,&#10;                email TEXT NOT NULL UNIQUE,&#10;                passwordHash TEXT NOT NULL,&#10;                salt TEXT NOT NULL&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Restaurants table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS restaurants (&#10;                id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                name TEXT NOT NULL,&#10;                address TEXT NOT NULL,&#10;                phoneNumber TEXT NOT NULL,&#10;                description TEXT,&#10;                shortDescription TEXT,&#10;                rating REAL,&#10;                videoUri TEXT,&#10;                image1Uri TEXT,&#10;                image2Uri TEXT&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Dishes table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS dishes (&#10;                id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                name TEXT NOT NULL,&#10;                description TEXT NOT NULL,&#10;                price REAL NOT NULL,&#10;                imageUrl TEXT&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Orders table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS orders (&#10;                orderId INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                userId INTEGER NOT NULL,&#10;                restaurantId INTEGER NOT NULL,&#10;                FOREIGN KEY (userId) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE,&#10;                FOREIGN KEY (restaurantId) REFERENCES restaurants(id) ON UPDATE CASCADE ON DELETE CASCADE&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create OrderElements table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS order_elements (&#10;                orderId INTEGER NOT NULL,&#10;                dishId INTEGER NOT NULL,&#10;                PRIMARY KEY (orderId, dishId),&#10;                FOREIGN KEY (orderId) REFERENCES orders(orderId) ON UPDATE CASCADE ON DELETE CASCADE,&#10;                FOREIGN KEY (dishId) REFERENCES dishes(id) ON UPDATE CASCADE ON DELETE CASCADE&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Reviews table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS reviews (&#10;                userId INTEGER NOT NULL,&#10;                restaurantId INTEGER NOT NULL,&#10;                rating REAL NOT NULL,&#10;                comment TEXT,&#10;                PRIMARY KEY (userId, restaurantId),&#10;                FOREIGN KEY (userId) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE,&#10;                FOREIGN KEY (restaurantId) REFERENCES restaurants(id) ON UPDATE CASCADE ON DELETE CASCADE&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // Create Menu Elements table&#10;        db?.execSQL(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS menu_elements (&#10;                restaurantId INTEGER NOT NULL,&#10;                dishId INTEGER NOT NULL,&#10;                PRIMARY KEY (restaurantId, dishId),&#10;                FOREIGN KEY (restaurantId) REFERENCES restaurants(id) ON UPDATE CASCADE ON DELETE CASCADE,&#10;                FOREIGN KEY (dishId) REFERENCES dishes(id) ON UPDATE CASCADE ON DELETE CASCADE&#10;            )&#10;        &quot;&quot;&quot;)&#10;&#10;        // insert premade data&#10;        insertPremadeUsers(db)&#10;        insertPremadeRestaurants(db)&#10;        insertPremadeDishes(db)&#10;        insertPremadeReviews(db)&#10;    }&#10;&#10;    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {&#10;        insertPremadeRestaurants(db)&#10;        // For major version changes, drop and recreate&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS menu_elements&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS reviews&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS order_elements&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS orders&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS dishes&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS restaurants&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS users&quot;)&#10;        onCreate(db)&#10;&#10;        insertPremadeRestaurants(db)&#10;    }&#10;&#10;&#10;    // example dishes&#10;    private  fun insertPremadeDishes(db: SQLiteDatabase?) {&#10;        val dishes = listOf(&#10;            Dish(&#10;                name = &quot;Margherita Pizza&quot;,&#10;                description = &quot;Classic pizza with tomato sauce, mozzarella cheese, and fresh basil&quot;,&#10;                price = 12.50&#10;            ),&#10;            Dish(&#10;                name = &quot;Spaghetti Carbonara&quot;,&#10;                description = &quot;Traditional Italian pasta with eggs, cheese, pancetta, and black pepper&quot;,&#10;                price = 14.00&#10;            ),&#10;            Dish(&#10;                name = &quot;Caesar Salad&quot;,&#10;                description = &quot;Fresh romaine lettuce, parmesan cheese, croutons with caesar dressing&quot;,&#10;                price = 9.50&#10;            ),&#10;            Dish(&#10;                name = &quot;Grilled Salmon&quot;,&#10;                description = &quot;Fresh salmon fillet grilled to perfection with lemon and herbs&quot;,&#10;                price = 18.00&#10;            ),&#10;            Dish(&#10;                name = &quot;Tiramisu&quot;,&#10;                description = &quot;Classic Italian dessert with coffee-soaked ladyfingers and mascarpone&quot;,&#10;                price = 6.50&#10;            ),&#10;            Dish(&#10;                name = &quot;Bruschetta&quot;,&#10;                description = &quot;Grilled bread topped with fresh tomatoes, garlic, and basil&quot;,&#10;                price = 7.00&#10;            ),&#10;            Dish(&#10;                name = &quot;Risotto ai Funghi&quot;,&#10;                description = &quot;Creamy rice dish with mixed mushrooms and parmesan cheese&quot;,&#10;                price = 15.50&#10;            ),&#10;            Dish(&#10;                name = &quot;Gelato&quot;,&#10;                description = &quot;Italian ice cream available in various flavors&quot;,&#10;                price = 4.50&#10;            )&#10;        )&#10;&#10;        dishes.forEach { dish -&gt;&#10;            db?.insert(&quot;dishes&quot;, null, dish.toContentValues())&#10;        }&#10;&#10;        // link dishes to restaurants in menu_elements table&#10;        val menuElements = listOf(&#10;            Pair(1, 1), // Spaghetti Carbonara to Symposium Cafe&#10;            Pair(1, 2), // Margherita Pizza to Symposium Cafe&#10;            Pair(2, 3),  // Caesar Salad to The Keg Oshawa&#10;            Pair(3, 4), // Grilled Salmon to Fazio's Italian Restaurant&#10;            Pair(3, 5), // Tiramisu to Fazio's Italian Restaurant&#10;            Pair(4, 6), // Bruschetta to Sushi Masa Japanese Restaurant&#10;            Pair(5, 7), // Risotto ai Funghi to Oshawa House Restaurant&#10;            Pair(5, 8)  // Gelato to Oshawa House Restaurant&#10;        )&#10;&#10;        menuElements.forEach { (restaurantId, dishId) -&gt;&#10;            val contentValues = android.content.ContentValues().apply {&#10;                put(&quot;restaurantId&quot;, restaurantId)&#10;                put(&quot;dishId&quot;, dishId)&#10;            }&#10;            db?.insert(&quot;menu_elements&quot;, null, contentValues)&#10;        }&#10;    }&#10;&#10;    // example restaurants&#10;    private fun insertPremadeRestaurants(db: SQLiteDatabase?) {&#10;        val restaurants = listOf(&#10;            Restaurant(&#10;                name = &quot;Symposium Cafe Restaurant &amp; Lounge&quot;,&#10;                description = &quot;A vibrant restaurant and lounge offering contemporary Canadian cuisine with international influences. Known for their extensive menu featuring everything from pasta and steaks to fresh salads and creative desserts. The atmosphere is warm and welcoming, perfect for both casual dining and special occasions.&quot;,&#10;                shortDescription = &quot;Contemporary Canadian cuisine&quot;,&#10;                rating = 0f,&#10;                address = &quot;1300 King St E, Oshawa, ON L1H 8J4&quot;,&#10;                phoneNumber = &quot;(905) 436-3354&quot;&#10;            ),&#10;            Restaurant(&#10;                name = &quot;The Keg Oshawa&quot;,&#10;                description = &quot;A classic steakhouse chain known for their premium steaks, fresh seafood, and signature caesar salads. The Keg offers a sophisticated dining experience with their dark wood decor and comfortable atmosphere. Their menu features AAA grade steaks, lobster, and an extensive wine selection.&quot;,&#10;                shortDescription = &quot;Premium steakhouse&quot;,&#10;                rating = 0f, // Will be calculated from reviews&#10;                address = &quot;1200 Thornton Rd N, Oshawa, ON L1H 7K4&quot;,&#10;                phoneNumber = &quot;(905) 433-3700&quot;&#10;            ),&#10;            Restaurant(&#10;                name = &quot;Fazio's Italian Restaurant&quot;,&#10;                description = &quot;Family-owned authentic Italian restaurant serving traditional recipes passed down through generations. Features homemade pasta, wood-fired pizza, and classic Italian entrees. The cozy atmosphere and friendly service make it feel like dining at an Italian family's home.&quot;,&#10;                shortDescription = &quot;Authentic Italian family dining&quot;,&#10;                rating = 0f, // Will be calculated from reviews&#10;                address = &quot;1668 Simcoe St N, Oshawa, ON L1G 4X6&quot;,&#10;                phoneNumber = &quot;(905) 436-3287&quot;&#10;            ),&#10;            Restaurant(&#10;                name = &quot;Sushi Masa Japanese Restaurant&quot;,&#10;                description = &quot;Fresh and authentic Japanese cuisine featuring expertly crafted sushi, sashimi, and traditional Japanese dishes. The chef uses only the finest ingredients to create beautiful presentations. The minimalist decor creates a peaceful dining environment perfect for enjoying the artistry of Japanese cuisine.&quot;,&#10;                shortDescription = &quot;Fresh authentic Japanese sushi&quot;,&#10;                rating = 0f, // Will be calculated from reviews&#10;                address = &quot;1300 King St E Unit 3, Oshawa, ON L1H 8J4&quot;,&#10;                phoneNumber = &quot;(905) 240-0888&quot;&#10;            ),&#10;            Restaurant(&#10;                name = &quot;Oshawa House Restaurant&quot;,&#10;                description = &quot;A local landmark serving comfort food and traditional favorites for over 30 years. Known for their generous portions, friendly service, and classic diner atmosphere. Popular for breakfast all day, hearty burgers, and homestyle dinners that remind you of home cooking.&quot;,&#10;                shortDescription = &quot;Classic comfort food diner&quot;,&#10;                rating = 0f, // Will be calculated from reviews&#10;                address = &quot;1425 King St E, Oshawa, ON L1H 8J6&quot;,&#10;                phoneNumber = &quot;(905) 579-4449&quot;&#10;            )&#10;        )&#10;&#10;        restaurants.forEach { restaurant -&gt;&#10;            db?.insert(&quot;restaurants&quot;, null, restaurant.toContentValues())&#10;        }&#10;    }&#10;&#10;    // insert premade users&#10;    private fun insertPremadeUsers(db: SQLiteDatabase?) {&#10;        if (db == null) return&#10;        &#10;        // Insert users directly during database creation to avoid recursion&#10;        val users = listOf(&#10;            Triple(&quot;Edoardo&quot;, &quot;edoardo.borlina@gmail.com&quot;, &quot;password&quot;),&#10;            Triple(&quot;Bralyn&quot;, &quot;bralynlp@gmail.com&quot;, &quot;password123&quot;),&#10;            Triple(&quot;User&quot;, &quot;user.example@email.com&quot;, &quot;password&quot;)&#10;        )&#10;        &#10;        users.forEach { (name, email, password) -&gt;&#10;            val salt = BCrypt.gensalt()&#10;            val passwordHash = BCrypt.hashpw(password, salt)&#10;            &#10;            val values = android.content.ContentValues().apply {&#10;                put(&quot;name&quot;, name)&#10;                put(&quot;email&quot;, email)&#10;                put(&quot;passwordHash&quot;, passwordHash)&#10;                put(&quot;salt&quot;, salt)&#10;            }&#10;            &#10;            db.insert(&quot;users&quot;, null, values)&#10;        }&#10;    }&#10;&#10;    // insert premade reviews&#10;    private fun insertPremadeReviews(db: SQLiteDatabase?) {&#10;        if (db == null) return&#10;&#10;        // Example reviews from different users&#10;        val reviews = listOf(&#10;            // Reviews for Symposium Cafe (restaurantId = 1)&#10;            Review(userId = 1, restaurantId = 1, rating = 4.0f, comment = &quot;Great atmosphere and delicious food!&quot;),&#10;            Review(userId = 2, restaurantId = 1, rating = 4.5f, comment = &quot;Love their desserts, highly recommended!&quot;),&#10;&#10;            // Reviews for The Keg Oshawa (restaurantId = 2)&#10;            Review(userId = 1, restaurantId = 2, rating = 5.0f, comment = &quot;Best steaks in town! Perfect cooking every time.&quot;),&#10;            Review(userId = 3, restaurantId = 2, rating = 4.0f, comment = &quot;Excellent service and quality meat.&quot;),&#10;&#10;            // Reviews for Fazio's Italian Restaurant (restaurantId = 3)&#10;            Review(userId = 2, restaurantId = 3, rating = 4.5f, comment = &quot;Authentic Italian cuisine, feels like home!&quot;),&#10;            Review(userId = 3, restaurantId = 3, rating = 5.0f, comment = &quot;The pasta is amazing, family-friendly atmosphere.&quot;),&#10;&#10;            // Reviews for Sushi Masa (restaurantId = 4)&#10;            Review(userId = 1, restaurantId = 4, rating = 4.5f, comment = &quot;Fresh sushi, beautiful presentation!&quot;),&#10;            Review(userId = 2, restaurantId = 4, rating = 4.0f, comment = &quot;Good quality fish, nice ambiance.&quot;),&#10;&#10;            // Reviews for Oshawa House Restaurant (restaurantId = 5)&#10;            Review(userId = 3, restaurantId = 5, rating = 4.0f, comment = &quot;Classic diner with great comfort food!&quot;)&#10;        )&#10;&#10;        reviews.forEach { review -&gt;&#10;            db.insert(&quot;reviews&quot;, null, review.toContentValues())&#10;        }&#10;&#10;        // Update restaurant ratings based on these reviews&#10;        for (restaurantId in 1..5) {&#10;            val avgRating = calculateAverageRatingFromDb(db, restaurantId)&#10;            val contentValues = android.content.ContentValues().apply {&#10;                put(&quot;rating&quot;, avgRating)&#10;            }&#10;            db.update(&quot;restaurants&quot;, contentValues, &quot;id = ?&quot;, arrayOf(restaurantId.toString()))&#10;        }&#10;    }&#10;&#10;    // Helper method to calculate average rating during onCreate (when db is being created)&#10;    private fun calculateAverageRatingFromDb(db: SQLiteDatabase, restaurantId: Int): Float {&#10;        val cursor = db.rawQuery(&#10;            &quot;SELECT AVG(rating) as avgRating FROM reviews WHERE restaurantId = ?&quot;,&#10;            arrayOf(restaurantId.toString())&#10;        )&#10;&#10;        var avgRating = 0f&#10;        if (cursor.moveToFirst()) {&#10;            val columnIndex = cursor.getColumnIndex(&quot;avgRating&quot;)&#10;            if (columnIndex != -1 &amp;&amp; !cursor.isNull(columnIndex)) {&#10;                avgRating = cursor.getFloat(columnIndex)&#10;            }&#10;        }&#10;        cursor.close()&#10;&#10;        return avgRating&#10;    }&#10;    /// Restaurants Table Methods&#10;&#10;    // Get all restaurants&#10;    fun getAllRestaurants(): List&lt;Restaurant&gt; {&#10;        val restaurants = mutableListOf&lt;Restaurant&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM restaurants&quot;, null)&#10;        while (cursor.moveToNext()) {&#10;            val restaurant: Restaurant = Restaurant.getFromCursor(cursor)&#10;            restaurants.add(restaurant)&#10;        }&#10;        cursor.close()&#10;        return restaurants&#10;    }&#10;&#10;    // insert a restaurant&#10;    fun insertRestaurant(restaurant: Restaurant){&#10;        val db = writableDatabase&#10;        db.insert(&quot;restaurants&quot;, null, restaurant.toContentValues())&#10;    }&#10;&#10;    // Update restaurant media (video and images)&#10;    fun updateRestaurantMedia(restaurantId: Int, videoUri: String?, image1Uri: String?, image2Uri: String?): Boolean {&#10;        val db = writableDatabase&#10;        val contentValues = android.content.ContentValues().apply {&#10;            put(&quot;videoUri&quot;, videoUri)&#10;            put(&quot;image1Uri&quot;, image1Uri)&#10;            put(&quot;image2Uri&quot;, image2Uri)&#10;        }&#10;        val result = db.update(&quot;restaurants&quot;, contentValues, &quot;id = ?&quot;, arrayOf(restaurantId.toString()))&#10;        return result &gt; 0&#10;    }&#10;&#10;&#10;    // Menu and Menu elements Methods&#10;    // Get menu for a restaurant given the name&#10;    fun getMenuForRestaurant(restaurantName: String): List&lt;Dish&gt; {&#10;        val dishes = mutableListOf&lt;Dish&gt;()&#10;        val db = readableDatabase&#10;        val query = &quot;&quot;&quot;&#10;            SELECT d.* FROM dishes d&#10;            JOIN menu_elements me ON d.id = me.dishId&#10;            JOIN restaurants r ON me.restaurantId = r.id&#10;            WHERE r.name = ?&#10;        &quot;&quot;&quot;&#10;        val cursor = db.rawQuery(query, arrayOf(restaurantName))&#10;        while (cursor.moveToNext()) {&#10;            val dish: Dish = Dish.getFromCursor(cursor)&#10;            dishes.add(dish)&#10;        }&#10;        cursor.close()&#10;        return dishes&#10;    }&#10;&#10;    // User Table Methods&#10;&#10;    // retrieve user by email&#10;    fun getUserByEmail(email: String): User? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM users WHERE email = ?&quot;, arrayOf(email))&#10;        var user: User? = null&#10;        if (cursor.moveToFirst()) {&#10;            user = User.getFromCursor(cursor)&#10;        }&#10;        cursor.close()&#10;        return user&#10;    }&#10;&#10;    // register user&#10;    fun registerUser(name: String, email: String, password: String): Boolean {&#10;        val db = writableDatabase&#10;&#10;        // check if user already exists&#10;        val existingUser = getUserByEmail(email)&#10;        if (existingUser != null) {&#10;            return false&#10;        }&#10;&#10;&#10;        val salt = BCrypt.gensalt()&#10;        val passwordHash = BCrypt.hashpw(password, salt)&#10;&#10;        val user = User(&#10;            name = name,&#10;            email = email,&#10;            passwordHash = passwordHash,&#10;            salt = salt&#10;        )&#10;&#10;        val result = db.insert(&quot;users&quot;, null, user.toContentValues())&#10;        return result != -1L&#10;    }&#10;&#10;    // autenticate userù&#10;    fun authenticateUser(email: String, password: String): User? {&#10;        val user = getUserByEmail(email) ?: return null&#10;&#10;        return if (BCrypt.checkpw(password, user.passwordHash)) {&#10;            user&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    // Review Methods&#10;&#10;    // Get all reviews for a restaurant&#10;    fun getReviewsForRestaurant(restaurantId: Int): List&lt;Review&gt; {&#10;        val reviews = mutableListOf&lt;Review&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM reviews WHERE restaurantId = ?&quot;, arrayOf(restaurantId.toString()))&#10;        while (cursor.moveToNext()) {&#10;            val review: Review = Review.getFromCursor(cursor)&#10;            reviews.add(review)&#10;        }&#10;        cursor.close()&#10;        return reviews&#10;    }&#10;&#10;    // Get review by user and restaurant (since user can only have one review per restaurant)&#10;    fun getUserReviewForRestaurant(userId: Int, restaurantId: Int): Review? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM reviews WHERE userId = ? AND restaurantId = ?&quot;,&#10;            arrayOf(userId.toString(), restaurantId.toString()))&#10;        var review: Review? = null&#10;        if (cursor.moveToFirst()) {&#10;            review = Review.getFromCursor(cursor)&#10;        }&#10;        cursor.close()&#10;        return review&#10;    }&#10;&#10;    // Insert or update a review (since user can only have one review per restaurant)&#10;    fun insertOrUpdateReview(review: Review): Boolean {&#10;        val db = writableDatabase&#10;        val result = db.insertWithOnConflict(&quot;reviews&quot;, null, review.toContentValues(),&#10;            android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE)&#10;&#10;        // Update restaurant rating after insertion/update&#10;        if (result != -1L) {&#10;            updateRestaurantRating(review.restaurantId)&#10;        }&#10;&#10;        return result != -1L&#10;    }&#10;&#10;    // Delete a review&#10;    fun deleteReview(userId: Int, restaurantId: Int): Boolean {&#10;        val db = writableDatabase&#10;        val result = db.delete(&quot;reviews&quot;, &quot;userId = ? AND restaurantId = ?&quot;,&#10;            arrayOf(userId.toString(), restaurantId.toString()))&#10;&#10;        // Update restaurant rating after deletion&#10;        if (result &gt; 0) {&#10;            updateRestaurantRating(restaurantId)&#10;        }&#10;&#10;        return result &gt; 0&#10;    }&#10;&#10;    // Calculate average rating for a restaurant&#10;    fun calculateAverageRating(restaurantId: Int): Float {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&#10;            &quot;SELECT AVG(rating) as avgRating FROM reviews WHERE restaurantId = ?&quot;,&#10;            arrayOf(restaurantId.toString())&#10;        )&#10;&#10;        var avgRating = 0f&#10;        if (cursor.moveToFirst()) {&#10;            val columnIndex = cursor.getColumnIndex(&quot;avgRating&quot;)&#10;            if (columnIndex != -1 &amp;&amp; !cursor.isNull(columnIndex)) {&#10;                avgRating = cursor.getFloat(columnIndex)&#10;            }&#10;        }&#10;        cursor.close()&#10;&#10;        return avgRating&#10;    }&#10;&#10;    // Update restaurant rating based on reviews&#10;    fun updateRestaurantRating(restaurantId: Int) {&#10;        val db = writableDatabase&#10;        val avgRating = calculateAverageRating(restaurantId)&#10;&#10;        val contentValues = android.content.ContentValues().apply {&#10;            put(&quot;rating&quot;, avgRating)&#10;        }&#10;&#10;        db.update(&quot;restaurants&quot;, contentValues, &quot;id = ?&quot;, arrayOf(restaurantId.toString()))&#10;    }&#10;&#10;    // Get restaurant by ID&#10;    fun getRestaurantById(restaurantId: Int): Restaurant? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM restaurants WHERE id = ?&quot;, arrayOf(restaurantId.toString()))&#10;        var restaurant: Restaurant? = null&#10;        if (cursor.moveToFirst()) {&#10;            restaurant = Restaurant.getFromCursor(cursor)&#10;        }&#10;        cursor.close()&#10;        return restaurant&#10;    }&#10;&#10;    // Get restaurant by name&#10;    fun getRestaurantByName(restaurantName: String): Restaurant? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM restaurants WHERE name = ?&quot;, arrayOf(restaurantName))&#10;        var restaurant: Restaurant? = null&#10;        if (cursor.moveToFirst()) {&#10;            restaurant = Restaurant.getFromCursor(cursor)&#10;        }&#10;        cursor.close()&#10;        return restaurant&#10;    }&#10;&#10;    // Get user name by ID&#10;    fun getUserNameById(userId: Int): String? {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT name FROM users WHERE id = ?&quot;, arrayOf(userId.toString()))&#10;        var userName: String? = null&#10;        if (cursor.moveToFirst()) {&#10;            userName = cursor.getString(cursor.getColumnIndexOrThrow(&quot;name&quot;))&#10;        }&#10;        cursor.close()&#10;        return userName&#10;    }&#10;&#10;    /// Order &amp; Order element Methods&#10;&#10;    // create order&#10;    fun createOrder(userId: Int, restaurantId: Int, dishIds: List&lt;Int&gt;): Boolean {&#10;        val db = writableDatabase&#10;        db.beginTransaction()&#10;        return try {&#10;            // Insert order&#10;            val orderValues = android.content.ContentValues().apply {&#10;                put(&quot;userId&quot;, userId)&#10;                put(&quot;restaurantId&quot;, restaurantId)&#10;            }&#10;            val orderId = db.insert(&quot;orders&quot;, null, orderValues)&#10;            if (orderId == -1L) {&#10;                throw Exception(&quot;Failed to create order&quot;)&#10;            }&#10;&#10;            // Insert order elements&#10;            dishIds.forEach { dishId -&gt;&#10;                val orderElementValues = android.content.ContentValues().apply {&#10;                    put(&quot;orderId&quot;, orderId)&#10;                    put(&quot;dishId&quot;, dishId)&#10;                }&#10;                val result = db.insert(&quot;order_elements&quot;, null, orderElementValues)&#10;                if (result == -1L) {&#10;                    throw Exception(&quot;Failed to add dish $dishId to order&quot;)&#10;                }&#10;            }&#10;&#10;            db.setTransactionSuccessful()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        } finally {&#10;            db.endTransaction()&#10;        }&#10;    }&#10;&#10;    // Get orders for a user&#10;    fun getOrdersForUser(userId: Int): List&lt;Order&gt; {&#10;        val orders = mutableListOf&lt;Order&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM orders WHERE userId = ?&quot;, arrayOf(userId.toString()))&#10;        while (cursor.moveToNext()) {&#10;            val order: Order = Order.getFromCursor(cursor)&#10;            orders.add(order)&#10;        }&#10;        cursor.close()&#10;        return orders&#10;    }&#10;&#10;    // Get or create an order for a user and restaurant&#10;    fun getOrCreateOrder(userId: Int, restaurantId: Int): Int? {&#10;        val db = writableDatabase&#10;        &#10;        // First, try to find existing order&#10;        val cursor = db.rawQuery(&#10;            &quot;SELECT orderId FROM orders WHERE userId = ? AND restaurantId = ?&quot;,&#10;            arrayOf(userId.toString(), restaurantId.toString())&#10;        )&#10;        &#10;        var orderId: Int? = null&#10;        if (cursor.moveToFirst()) {&#10;            orderId = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;orderId&quot;))&#10;        }&#10;        cursor.close()&#10;        &#10;        // If no order exists, create one&#10;        if (orderId == null) {&#10;            val orderValues = android.content.ContentValues().apply {&#10;                put(&quot;userId&quot;, userId)&#10;                put(&quot;restaurantId&quot;, restaurantId)&#10;            }&#10;            val newOrderId = db.insert(&quot;orders&quot;, null, orderValues)&#10;            orderId = if (newOrderId != -1L) newOrderId.toInt() else null&#10;        }&#10;        &#10;        return orderId&#10;    }&#10;&#10;    // remove element from order&#10;    fun removeDishFromOrder(orderId: Int, dishId: Int): Boolean {&#10;        val db = writableDatabase&#10;        val result = db.delete(&quot;order_elements&quot;, &quot;orderId = ? AND dishId = ?&quot;,&#10;            arrayOf(orderId.toString(), dishId.toString()))&#10;        return result &gt; 0&#10;    }&#10;&#10;    // add element to order&#10;    fun addDishToOrder(orderId: Int, dishId: Int): Boolean {&#10;        val db = writableDatabase&#10;        &#10;        // Check if dish is already in order&#10;        val cursor = db.rawQuery(&#10;            &quot;SELECT * FROM order_elements WHERE orderId = ? AND dishId = ?&quot;,&#10;            arrayOf(orderId.toString(), dishId.toString())&#10;        )&#10;        val alreadyExists = cursor.count &gt; 0&#10;        cursor.close()&#10;        &#10;        if (alreadyExists) {&#10;            // Dish already in order, return true (already added)&#10;            return true&#10;        }&#10;        &#10;        val orderElementValues = OrderElement(&#10;            orderId = orderId,&#10;            dishId = dishId&#10;        ).toContentValues()&#10;        val result = db.insert(&quot;order_elements&quot;, null, orderElementValues)&#10;        return result != -1L&#10;    }&#10;&#10;    // Get all dishes in an order&#10;    fun getOrderItems(orderId: Int): List&lt;Dish&gt; {&#10;        val dishes = mutableListOf&lt;Dish&gt;()&#10;        val db = readableDatabase&#10;        val query = &quot;&quot;&quot;&#10;            SELECT d.* FROM dishes d&#10;            JOIN order_elements oe ON d.id = oe.dishId&#10;            WHERE oe.orderId = ?&#10;        &quot;&quot;&quot;&#10;        val cursor = db.rawQuery(query, arrayOf(orderId.toString()))&#10;        while (cursor.moveToNext()) {&#10;            val dish = Dish.getFromCursor(cursor)&#10;            dishes.add(dish)&#10;        }&#10;        cursor.close()&#10;        return dishes&#10;    }&#10;&#10;    // Count items in an order&#10;    fun getOrderItemsCount(orderId: Int): Int {&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&#10;            &quot;SELECT COUNT(*) FROM order_elements WHERE orderId = ?&quot;,&#10;            arrayOf(orderId.toString())&#10;        )&#10;        var count = 0&#10;        if (cursor.moveToFirst()) {&#10;            count = cursor.getInt(0)&#10;        }&#10;        cursor.close()&#10;        return count&#10;    }&#10;&#10;    // Calculate total price of an order&#10;    fun getOrderTotal(orderId: Int): Double {&#10;        val db = readableDatabase&#10;        val query = &quot;&quot;&quot;&#10;            SELECT SUM(d.price) as total FROM dishes d&#10;            JOIN order_elements oe ON d.id = oe.dishId&#10;            WHERE oe.orderId = ?&#10;        &quot;&quot;&quot;&#10;        val cursor = db.rawQuery(query, arrayOf(orderId.toString()))&#10;        var total = 0.0&#10;        if (cursor.moveToFirst()) {&#10;            val columnIndex = cursor.getColumnIndex(&quot;total&quot;)&#10;            if (columnIndex != -1 &amp;&amp; !cursor.isNull(columnIndex)) {&#10;                total = cursor.getDouble(columnIndex)&#10;            }&#10;        }&#10;        cursor.close()&#10;        return total&#10;    }&#10;&#10;}&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>